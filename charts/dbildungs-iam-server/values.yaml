nameOverride: ""
fullnameOverride: ""
namespaceOverride: ""

backendHostname: ""
keycloakHostname: ""

containerSecurityContext:
  enabled: true
  runAsUser: 1000
  runAsNonRoot: true
  privileged: false
  readOnlyRootFilesystem: false
  allowPrivilegeEscalation: false
  capabilities:
    drop: ["ALL"]
  seccompProfile:
    type: "RuntimeDefault"

restartPolicy: Always
environment: prod

database:
  name: "dbildungs_iam_server"
  host: ""
  password: ""
  username: "dbildungs_iam_server"

auth:
  # existingSecret: Refers to a secret already present in the cluster, which is required.
  existingSecret: ""
  secretName: dbildungs-iam-server
  keycloak_adminSecret: ""
  keycloak_clientSecret: ""
  secrets_json: ""
  frontend_sessionSecret: ""


backend:
  replicaCount: 1
  image:
    repository: ghcr.io/dbildungsplattform/dbildungs-iam-server
    tag: ""
    pullPolicy: Always
  containerPorts:
    http: 8080
  resources:
    limits:
      cpu: 2
      memory: 4G
    requests:
      cpu: 200m
      memory: 200Mi
  startupProbe:
    enabled: true
    initialDelaySeconds: 60
    periodSeconds: 60
    failureThreshold: 5
    httpGet:
      scheme: 'HTTP'
      port: 8080
      path: '/health'
  livenessProbe:
    enabled: true
    initialDelaySeconds: 10
    httpGet:
      scheme: 'HTTP'
      port: 8080
      path: '/health'
  readinessProbe:
    enabled: true
    initialDelaySeconds: 10
    httpGet:
      scheme: 'HTTP'
      port: 8080
      path: '/health'
  dbseeding:
    enabled: true
    command: [ "node", "dist/src/console/main.js", "db", "seed", "dev", "" ]
  ingress:
    enabled: true
    ingressClassName: nginx
    pathType: Prefix
    portnumber: 80
    automountServiceAccountToken: false
    paths:
      - /api
      - /docs
      - /docs-json
      - /docs-yaml
    annotations: []
  service:
    type: ClusterIP
    ports:
      http: 80
  serviceMonitor:
    enabled: true
    endpoints:
      - port: "web"
  extraEnvVars: []
  extraVolumes: []
  volumeMounts:
    - mountPath: /app/config/config.json
      subPath: config-json
      name: config-volume
      readOnly: true
    - mountPath: /app/config/secrets.json
      subPath: secrets-json
      name: secret-volume
  extraVolumeMounts: []


redis:
  image:
    name: redis
    repository: redis
    tag: "7.2.4"
    pullPolicy: IfNotPresent
  args:
    - "/data/tls/redis.conf"
  containerPorts:
    redis: 6379
  resources:
    limits:
      cpu: 2
      memory: 4G
    requests:
      cpu: 200m
      memory: 200Mi
  livenessProbe:
    enabled: true
    tcpSocket:
      port: 6379
    initialDelaySeconds: 15
    timeoutSeconds: 2
  readinessProbe:
    enabled: true
    tcpSocket:
      port: 6379
    initialDelaySeconds: 5
    timeoutSeconds: 1
  startupProbe:
    enabled: true
    tcpSocket:
      port: 6379
    failureThreshold: 30
    periodSeconds: 10
  service:
    type: ClusterIP
    ports:
      redis: 6379
  extraEnvVars: []
  extraVolumes: []
  extraVolumeMounts: []
redis-cluster:
  enabled: true
  password: "password"
  cluster:
      ## Number of Redis&reg; nodes to be deployed
      ##
      ## Note:
      ## This is total number of nodes including the replicas. Meaning there will be 3 master and 3 replica
      ## nodes (as replica count is set to 1 by default, there will be 1 replica per master node).
      ## Hence, nodes = numberOfMasterNodes + numberOfMasterNodes * replicas
      ##
      ## @param cluster.nodes The number of master nodes should always be >= 3, otherwise cluster creation will fail
      ##
      nodes: 6
      ## @param cluster.replicas Number of replicas for every master in the cluster
      ## Parameter to be passed as --cluster-replicas to the redis-cli --cluster create
      ## 1 means that we want a replica for every master created
      ##
      replicas: 1   
  networkPolicy:
    ## @param networkPolicy.enabled Enable creation of NetworkPolicy resources
    ##
    enabled: false
  serviceAccount:
  ## @param serviceAccount.create Specifies whether a ServiceAccount should be created
  ##
    create: false

  redis:
    initContainers:
    - name: generate-tls-certs
      image: alpine
      securityContext:
        allowPrivilegeEscalation: false
      command: ["/bin/sh", "-c"]
      args: ["apk add --no-cache openssl bash; /bin/bash /data/tls/gencert.sh && /bin/bash /data/tls/copy-tls.sh"]
      volumeMounts:
        - name: redis-tls-data
          mountPath: /data/tls
    env:
      - name: REDIS_TLS_ENABLED
        value: "yes"
      - name: REDIS_TLS_CERT_FILE
        value: /data/tls/redis.crt
      - name: REDIS_TLS_KEY_FILE
        value: /data/tls/redis.key
      - name: REDIS_TLS_CA_FILE
        value: /data/tls/ca.crt
    extraVolumes:
    - name: redis-tls-data
      emptyDir: {}
    extraVolumeMounts:
    - name: redis-tls-data
      mountPath: /data/tls
      readOnly: true
    usePassword: false
    username: "default"
    password: "password"
    tls:
      enabled: true
    volumePermissions:
      enabled: false
    extraVolumes:
      - name: redis-tls-data
        configMap:
          name: dbildungs-iam-server-redis-tls-data
          items:
            - key: gencert.sh
              path: gencert.sh
            - key: copy-tls.sh
              path: copy-tls.sh
            - key: redis.conf
              path: redis.conf
    podLabels:
      app.kubernetes.io/component: server-redis
  commonLabels:
    app.kubernetes.io/name: dbildungs-iam-server 